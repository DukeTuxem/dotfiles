"
"           |  \
"  __     __ \▓▓______ ____   ______   _______
" |  \   /  \  \      \    \ /      \ /       \
"  \▓▓\ /  ▓▓ ▓▓ ▓▓▓▓▓▓\▓▓▓▓\  ▓▓▓▓▓▓\  ▓▓▓▓▓▓▓
"   \▓▓\  ▓▓| ▓▓ ▓▓ | ▓▓ | ▓▓ ▓▓   \▓▓ ▓▓
"    \▓▓ ▓▓ | ▓▓ ▓▓ | ▓▓ | ▓▓ ▓▓     | ▓▓_____
"     \▓▓▓  | ▓▓ ▓▓ | ▓▓ | ▓▓ ▓▓      \▓▓     \
"      \▓    \▓▓\▓▓  \▓▓  \▓▓\▓▓       \▓▓▓▓▓▓▓


" Always use the XDG Base Directory specification {{{

" copied from: https://wiki.archlinux.org/title/XDG_Base_Directory

" :h set-args (^=)
set runtimepath^=$XDG_CONFIG_HOME/vim
set runtimepath+=$XDG_DATA_HOME/vim
set runtimepath+=$XDG_CONFIG_HOME/vim/after

set packpath^=$XDG_DATA_HOME/vim,$XDG_CONFIG_HOME/vim
set packpath+=$XDG_CONFIG_HOME/vim/after,$XDG_DATA_HOME/vim/after

let g:netrw_home = $XDG_DATA_HOME."/vim"
call mkdir($XDG_DATA_HOME."/vim/spell", 'p')

set backupdir=$XDG_CACHE_HOME/vim/backup | call mkdir(&backupdir, 'p')
set directory=$XDG_CACHE_HOME/vim/swap   | call mkdir(&directory, 'p')
set undodir=$XDG_CACHE_HOME/vim/undo     | call mkdir(&undodir,   'p')
set viewdir=$XDG_STATE_HOME/vim/view     | call mkdir(&viewdir,   'p')

call mkdir($XDG_STATE_HOME."/vim", 'p')
if !has('nvim') | set viminfofile=$XDG_STATE_HOME/vim/viminfo | endif
" }}}
" Autoinstall plugin manager and plugins if missing {{{
if empty(glob('$XDG_CONFIG_HOME/vim/autoload/plug.vim'))
  silent !curl -fLo $XDG_CONFIG_HOME/vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd! VimEnter * PlugInstall --sync | source $MYVIMRC
endif
" run PlugInstall if there are missing plugins
autocmd! VimEnter * if len(filter(values(g:plugs), '!isdirectory(v:val.dir)'))
	\ | PlugInstall --sync | source $MYVIMRC | endif
" }}}

call plug#begin('$XDG_CONFIG_HOME/vim/.vim-plug')
" UI
Plug 'Yggdroot/indentLine'	" show indent levels of spaces
Plug 'preservim/tagbar'         " outline symbols (requires ctags)
Plug 'junegunn/fzf'
" motions
Plug 'tpope/vim-commentary'	" gcc / gcap / ...
Plug 'tpope/vim-surround'	" cs([
Plug 'romainl/vim-cool'		" see: /and vim-cool

Plug 'tpope/vim-obsession'      " nice to create sessions

Plug 'tpope/vim-repeat'

" ToImplement
Plug 'itchyny/lightline.vim'	" lighter status bar than airline
Plug 'tpope/vim-fugitive'       " Stage current file from vim, restore...
Plug 'airblade/vim-gitgutter'   " Actual modifications inside the buffer
Plug 'tpope/vim-vinegar'

" themes
Plug 'chriskempson/base16-vim'	" cool to test completion
Plug 'joshdick/onedark.vim'	" kind of fallback...
Plug 'vimwiki/vimwiki'
call plug#end()


let mapleader = "\\"

" todo: function keys section
nnoremap <F2> :set wrap!<CR>


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" User Interface (return from the screen)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Terminal: (parent process)
set title
set titlestring=VIM

" Appearance:
set number		" show the line numbers on the left side...
set relativenumber	" ...with the numbers relative to the current line
set colorcolumn=80	" show a limit with a vertical mark bar
set conceallevel=0	" never replace any symbol like lambda sign, whatever
set nowrap		" allow long lines to extend as far as they go

set belloff=all		" no bell
set novisualbell	" disable sound
set vb t_vb=		" clearing the visual bell length deactivates flashing

" <plugin> mark indentation levels
let g:indentLine_char = '┊'
let g:indentLine_setColors = 1

" keep the cursor centered
nnoremap n nzzzv
nnoremap N Nzzzv
nnoremap J mzJ`z
nnoremap <C-d>  <C-d>zz
nnoremap <C-u>  <C-u>zz

" Splits:
" more natural default behavior
set splitbelow
set splitright

" create quick splits
nnoremap <silent> <leader>s :split<CR>
nnoremap <silent> <leader>v :vsplit<CR>

" navigation shortcuts
" vimwiki (Backspace key)
nnoremap <C-h>		<C-w>h
nnoremap <C-j>		<C-w>j
nnoremap <C-k>		<C-w>k
nnoremap <C-l>		<C-w>l

nnoremap <C-Up>		<C-w>k
nnoremap <C-Left>	<C-w>h
nnoremap <C-Down>	<C-w>j
nnoremap <C-Right>	<C-w>l


" Tabs:
" better to <C-W>T on a previous buffer
" nnoremap <silent> <leader>t :tabnew<CR>
" non layout destructive :bd
nnoremap <silent> <leader>d :b#<bar>bw!#<CR>
" window/tab destructive :bd
nnoremap <silent> <leader>D :bd<CR>
" shortcut of of the shortcut <C-w>c
nnoremap <silent> <leader>c :close<CR>

nnoremap <silent> <leader>l :ls<CR>
nnoremap <silent> <leader>L :ls!<CR>
nnoremap <silent> <leader>q :bprev<CR>
nnoremap <silent> <leader>p :bnext<CR>
nnoremap <leader>e :enew<CR>


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Edition (fed to the process) in the idea
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

set mouse=a

set backspace=indent,eol,start	" erase back even in insert mode

set textwidth=80	" do break text with a newline after n typped chars

set noautochdir        " autochdir changes the global directory, not win/tab

" Files:
set encoding=UTF-8
set autoread		" reload files changed outside vim
set modeline		" enable <fileCommentChar> vim: fdm=marker
set modelines=1		" limit lines to read

" Tabs:			(Historical reason to choose 8 as a default)
set tabstop=8		" number of spaces that a <Tab> in a file counts for
set shiftwidth=0	" number of spaces to use for each step of (auto)indent
set softtabstop=0	" do not mix space and tabs to make up a set spacing
set noexpandtab		" never replace tabs with space

" Search:
set hlsearch		" highlight searches by default
set incsearch		" find the next match as we type the search
set ignorecase		" ignore case when searching...
set smartcase		" ...unless we type an uppercase letter

" Completion_menu:
set wildmenu	" do not spam TAB in command line
set wildmode=list:longest,list:lastused,list:full
set wildignore=*.jpg,*.png,*.gif,*.pdf,*.pyc,*.flv,*.img
"set wildchar=<Tab> wildmenu wildmode=full

"set matchtime=3        " ... and shorten the default time -> zt zb zz H M L
"set scrolloff=5        " scroll before the end of buffer but affect H/M/L too
nnoremap S :.,$s//gc<Left><Left><Left>
" and vim-cool is used to remove highlighted searches automatically (no :nohl)

" Folds:
set fdm=marker
set foldenable
set foldlevelstart=0	" close most folds by default
set foldnestmax=10	" open most folds by default

" Tell vim to remember certain things when we exit
"  '10   :  marks will be remembered for up to 10 previously edited files
"  "1000 :  will save up to 1000 lines for each register
"  :20   :  up to 20 lines of command-line history will be remembered
"  %     :  saves and restores the buffer list
"  h     :  disable the effect of 'hlsearch'
"  n...  :  where to save the viminfo files | viminfofile set above
set viminfo='10,\"1000,:20,%,h

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Color
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" use truecolor (24bit-mode)
set termguicolors

if &term =~ "^st"
	" from :help xterm-true-color
	let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
	let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"

	" Fixes mouse scrolling in st. Update: it seems fixed
	"set ttymouse=sgr
endif

colorscheme my-eighties



"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Statusline
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set showcmd		" show the command being typed. Ex: "a
set noruler		" deactivate line:column in ruler (handled in plugin)
set showmatch		" briefly highlight the matching ( { [ if any

"-- lightline settings
set noshowmode
set laststatus=2
let g:lightline = {
\ 'colorscheme': 'darcula',
\ }

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Command Line
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" arrow up/down in :cmdline
cnoremap <C-k> <Up>
cnoremap <C-j> <Down>

" typos
" no need if we flip ; with :
cnoreabbrev E e
cnoreabbrev Q q
cnoreabbrev Qa qa
cnoreabbrev W w

" remap colon to semicolon
nnoremap ; :
nnoremap : ;
vnoremap ; :
vnoremap : ;

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Fuzzy Finding
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

nnoremap <leader>f :FZF<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Function keys
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" F1 : Help
nnoremap <F2> :set wrap!<CR>
" TODO: Remap CTRL-V to include it ?
set pastetoggle=<F3>
nnoremap <F4> :set list!<CR>

nnoremap <F12> :call g:SynStack()<CR>


" git
nmap <leader>Hp  <Plug>(GitGutterPreviewHunk)
nmap <leader>Hu  <Plug>(GitGutterUndoHunk)
nmap <leader>Hs  <Plug>(GitGutterStageHunk)
xmap <leader>Hs  <Plug>(GitGutterStageHunk)


augroup onFocusAttemptToTriggerAutoread
	autocmd!
	" note: this is still not close to real-time
	autocmd FocusGained,BufEnter * :checktime
augroup END

" enhancement {{{

" perform dot commands over visual blocks:
vnoremap . :normal .<CR>


" netrw
let g:netrw_banner = 0
let g:netrw_liststyle = 3
let g:netrw_browse_split = 4
let g:netrw_altv = 1
let g:netrw_winsize = 25
nnoremap <leader>x :Vex<CR>
" }}}

" consistent mapping
nnoremap Y y$

" allow netrw buffers to be closed
let g:netrw_fastbrowse = 0


" explicit mappings to avoid weird behavior on some terminal emulators {{{
" example: urxvt and st have some trouble dealing 'natively'
" with Ctrl/Alt + Left/Right while others (kitty, xterm) handle it smoothly
" Better to set it anyway.


" Ctrl
" nmap <ESC>[1;5D <C-Left>
" nmap <ESC>[1;5C <C-Right>
" cmap <ESC>[1;5D <C-Left>
" cmap <ESC>[1;5C <C-Right>
" imap <ESC>[1;5D <C-o><C-Left>
" imap <ESC>[1;5C <C-o><C-Right>
" " Alt
" nmap <ESC>[1;3D <Nop>
" nmap <ESC>[1;3C <Nop>
" cmap <ESC>[1;3D <Nop>
" cmap <ESC>[1;3C <Nop>
" imap <ESC>[1;3D <Nop>
" imap <ESC>[1;3C <Nop>

" highlight trailing spaces in red {{{
augroup HighlightUselessWhitespaceInRed
	autocmd!

	" does not get triggered whilst you are typing in insert mode
	:highlight ExtraWhitespace ctermbg=darkred guibg=darkred
	autocmd ColorScheme * highlight ExtraWhitespace ctermbg=red guibg=red
	match ExtraWhitespace /\s\+$/
	autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
	autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
	autocmd InsertLeave * match ExtraWhitespace /\s\+$/
	autocmd BufWinLeave * call clearmatches()
augroup END

" automatically restore the previous cursor position {{{
function! ResCur()
  if line("'\"") <= line("$")
    normal! g`"
    return 1
  endif
endfunction

augroup resCur
  autocmd!
  autocmd BufWinEnter * call ResCur()
augroup END

" keywords: - vim.fandom.com
"           - restore_cursor_to_file_position_in_previous_editing_session
" }}}
" Ag as grep {{{
set grepprg=ag\ --color\ --vimgrep

function! Grep(...)
	echo join([&grepprg] + [expandcmd(join(a:000, ' '))], ' ')
	return system(join([&grepprg] + [expandcmd(join(a:000, ' '))], ' '))
endfunction
command! -nargs=+ -complete=file_in_path -bar Grep  cgetexpr Grep(<f-args>)
cnoreabbrev <expr> grep  (getcmdtype() ==# ':' && getcmdline() ==# 'grep')  ?  'Grep'  : 'grep'
command! -nargs=+ -complete=file_in_path -bar LGrep lgetexpr Grep(<f-args>)
cnoreabbrev <expr> lgrep (getcmdtype() ==# ':' && getcmdline() ==# 'lgrep') ?  'LGrep' : 'lgrep'

" if any match, send the output of the Grep command to the quickfix list and set the cursor inside
augroup quickfix
	autocmd!
	autocmd QuickFixCmdPost cgetexpr cwindow
	autocmd QuickFixCmdPost lgetexpr lwindow
	" autocmd QuickFixCmdPost grep cwindow
augroup END
" }}}

" Plugins config
let g:vimwiki_list = [{'path': '~/vimwiki/',
			\ 'syntax': 'markdown', 'ext': '.md'}]

augroup onVimwikiBindShiftBackspace
	autocmd!
	autocmd FileType vimwiki nnoremap <silent><buffer> <C-H> :VimwikiGoBackLink<CR>
augroup END


augroup onVimEnterRestoreSessionIfAny
	autocmd!
	function! RestoreSess()
		if filereadable(expand("~/Session.vim"))
			source ~/Session.vim
		endif
	endfunction

	" :h automcmd-nested
	autocmd VimEnter * nested call RestoreSess()
augroup END


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Vimrc
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

augroup sourceVimrcOnSave
	autocmd!
	autocmd BufWritePost * nested if expand($MYVIMRC) ==# expand('%:p')
				\ | source $MYVIMRC
				\ | echo ".vimrc saved and reloaded!"
				\ | endif
augroup END

" quick edit vimrc in a new tab
nnoremap <silent> <leader>V :tabnew $MYVIMRC<CR>zozz
