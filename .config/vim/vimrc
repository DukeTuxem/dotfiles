"
"           |  \
"  __     __ \▓▓______ ____   ______   _______
" |  \   /  \  \      \    \ /      \ /       \
"  \▓▓\ /  ▓▓ ▓▓ ▓▓▓▓▓▓\▓▓▓▓\  ▓▓▓▓▓▓\  ▓▓▓▓▓▓▓
"   \▓▓\  ▓▓| ▓▓ ▓▓ | ▓▓ | ▓▓ ▓▓   \▓▓ ▓▓
"    \▓▓ ▓▓ | ▓▓ ▓▓ | ▓▓ | ▓▓ ▓▓     | ▓▓_____
"     \▓▓▓  | ▓▓ ▓▓ | ▓▓ | ▓▓ ▓▓      \▓▓     \
"      \▓    \▓▓\▓▓  \▓▓  \▓▓\▓▓       \▓▓▓▓▓▓▓

" written and (mostly) tested with version 9.0 on Linux
" _____________________________________________________________________________

" TODO: netrw ergonomics
" see the following : noautochdir
" Session prevents opening a random file elsewhere
" redraw with autocmd BufWritePost makes vim-cool bug (how to autoaccept ?)
" tags generation function / workflow
" git config
" Ale
" Completion
" create own status line

" Always use the XDG Base Directory specification {{{
" copied from: https://wiki.archlinux.org/title/XDG_Base_Directory

" :h set-args (^=)
set runtimepath^=$XDG_CONFIG_HOME/vim
set runtimepath+=$XDG_DATA_HOME/vim
set runtimepath+=$XDG_CONFIG_HOME/vim/after

set packpath^=$XDG_DATA_HOME/vim,$XDG_CONFIG_HOME/vim
set packpath+=$XDG_CONFIG_HOME/vim/after,$XDG_DATA_HOME/vim/after

let g:netrw_home = $XDG_DATA_HOME."/vim"
call mkdir($XDG_DATA_HOME."/vim/spell", 'p')

set backupdir=$XDG_CACHE_HOME/vim/backup | call mkdir(&backupdir, 'p')
set directory=$XDG_CACHE_HOME/vim/swap   | call mkdir(&directory, 'p')
set undodir=$XDG_CACHE_HOME/vim/undo     | call mkdir(&undodir,   'p')
set viewdir=$XDG_STATE_HOME/vim/view     | call mkdir(&viewdir,   'p')

call mkdir($XDG_STATE_HOME."/vim", 'p')
if !has('nvim') | set viminfofile=$XDG_STATE_HOME/vim/viminfo | endif
" }}}

" Plugin list : {{{

" install the plugin manager if not present {{{
if empty(glob('$XDG_CONFIG_HOME/vim/autoload/plug.vim'))
  silent !curl -fLo $XDG_CONFIG_HOME/vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd! VimEnter * PlugInstall --sync | source $MYVIMRC
endif
" }}}
" run PlugInstall if there are missing plugins {{{
autocmd! VimEnter * if len(filter(values(g:plugs), '!isdirectory(v:val.dir)'))
	\ | PlugInstall --sync | source $MYVIMRC | endif
" }}}

call plug#begin('$XDG_CONFIG_HOME/vim/.vim-plug')
" UI
Plug 'Yggdroot/indentLine'	" show indent levels of spaces
Plug 'preservim/tagbar'         " outline symbols (requires ctags)
Plug 'junegunn/fzf'
" motions
Plug 'tpope/vim-commentary'	" gcc / gcap / ...
Plug 'tpope/vim-surround'	" cs
Plug 'romainl/vim-cool'		" see: /and vim-cool

Plug 'tpope/vim-obsession'      " nice to create sessions

" ToImplement
Plug 'itchyny/lightline.vim'	" lighter status bar than airline
Plug 'tpope/vim-fugitive'       " Stage current file from vim, restore...
Plug 'airblade/vim-gitgutter'   " Actual modifications inside the buffer
Plug 'tpope/vim-vinegar'

" themes
Plug 'chriskempson/base16-vim'	" cool to test completion
Plug 'joshdick/onedark.vim'	" kind of fallback...
call plug#end()

nnoremap <leader>f :FZF<CR>

" Yggdroot/indentLine
let g:indentLine_char = '┊'
let g:indentLine_setColors = 0

" lightline (more minimalistic than airline)
set noshowmode
set laststatus=2
let g:lightline = {
\ 'colorscheme': 'darcula',
\ }

" git
nmap <leader>Hp  <Plug>(GitGutterPreviewHunk)
nmap <leader>Hu  <Plug>(GitGutterUndoHunk)
nmap <leader>Hs  <Plug>(GitGutterStageHunk)
xmap <leader>Hs  <Plug>(GitGutterStageHunk)
" }}}

" Editing {{{

set title
set titlestring=VIM

set encoding=UTF-8

set mouse=a

" appearance {{{
set number             " show the line numbers on the left side...
set relativenumber     " ...with the numbers relative to the current line
set colorcolumn=80     " show the limit with a vertical mark bar
set conceallevel=0     " never replace any symbol like lambda sign, whatever
set nowrap             " allow long lines to extend as far as they go
set showcmd            " show the command being typed. Ex: "a
set noruler            " deactivate line:column in ruler (handled in plugin)
set showmatch          " briefly highlight the matching ( { [ if any
"set matchtime=3        " ... and shorten the default time -> zt zb zz H M L
"set cursorline         " underline the cursor line position with a marker
"set cursorcolumn       " same but vertically
"set scrolloff=5        " scroll before the end of buffer but affect H/M/L too
set termguicolors      " enable support for truecolor (24bit)
" }}}
" tab settings {{{
set tabstop=4          " number of spaces that a <Tab> in the file counts for
set shiftwidth=4	   " number of spaces followed by a newline
set softtabstop=4	   " number of spaces that is inserted when you hit <TAB>
set noexpandtab        " replace tabs with space
" }}}
" search {{{
set hlsearch           " highlight searches by default
set incsearch          " find the next match as we type the search
set ignorecase         " ignore case when searching...
set smartcase          " ...unless we type an uppercase letter
nnoremap S :%s//gc<Left><Left><Left>
" and vim-cool is used to remove highlighted searches automatically (no :nohl)
" }}}
" completion menu {{{
set wildmenu              	" do not spam TAB in command line
set wildmode=list:longest,list:lastused,list:full
set wildignore=*.jpg,*.png,*.gif,*.pdf,*.pyc,*.flv,*.img
"set wildchar=<Tab> wildmenu wildmode=full
" }}}
" folds {{{
set foldenable
set foldlevelstart=0   " close most folds by default
set foldnestmax=10     " open most folds by default
" }}}
" behavior {{{
set hidden             " allow hidden buffers (instead of unloading them)
set splitbelow         " split more...
set splitright         " ... naturally
set textwidth=0        " do not break text with a newline after n typped chars

set belloff=all        " no bell
set novisualbell       " disable sound
set vb t_vb=           " clearing the visual bell length deactivates flashing

set modeline           " enable <fileCommentChar> vim: fdm=marker
set modelines=1        " limit lines to read

set autoread           " reload files changed outside vim
augroup onFocusAttemptToTriggerAutoread
	autocmd!
	" note: this is still not close to real-time
	autocmd FocusGained,BufEnter * :checktime
augroup END

" TODO: set the working directory to the current edited file location
set noautochdir        " autochdir changes the global directory, not win/tab
"augroup lcdToCurrentFileLoc
"	autocmd!
"	autocmd BufEnter * lcd %:p:h
"augroup END

set backspace=indent,eol,start	" erase back even in insert mode

" Tell vim to remember certain things when we exit
"  '10   :  marks will be remembered for up to 10 previously edited files
"  "1000 :  will save up to 1000 lines for each register
"  :20   :  up to 20 lines of command-line history will be remembered
"  %     :  saves and restores the buffer list
"  h     :  disable the effect of 'hlsearch'
"  n...  :  where to save the viminfo files | viminfofile set above
set viminfo='10,\"1000,:20,%,h
" }}}
" enhancement {{{

augroup openHelpToTheRight
	autocmd!
	" :h wincmd (T/O/HJKL)
	autocmd BufEnter *.txt if &filetype == 'help' | wincmd T | endif
augroup END

" perform dot commands over visual blocks:
vnoremap . :normal .<CR>

" keep the cursor centered
nnoremap n nzzzv
nnoremap N Nzzzv
nnoremap J mzJ`z
nnoremap <C-d>  <C-d>zz
nnoremap <C-u>  <C-u>zz

" arrow up/down in :cmdline
cnoremap <C-k> <Up>
cnoremap <C-j> <Down>

" typos
cnoreabbrev E e
cnoreabbrev Q q
cnoreabbrev Qa qa
cnoreabbrev W w

" netrw
let g:netrw_banner = 0
let g:netrw_liststyle = 3
let g:netrw_browse_split = 4
let g:netrw_altv = 1
let g:netrw_winsize = 25
nnoremap <leader>x :Vex<CR>
" }}}
" fixes {{{

" consistent mapping
nnoremap Y y$

" allow netrw buffers to be closed
let g:netrw_fastbrowse = 0

" necessary color fix for st
if &term =~ "^st"
	let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"  " from :help xterm-true-color
	let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"  " from :help xterm-true-color

	" Fixes mouse scrolling in st. Update: it seems fixed
	"set ttymouse=sgr
endif

" explicit mappings to avoid weird behavior on some terminal emulators {{{
" example: urxvt and st have some trouble dealing 'natively'
" with Ctrl/Alt + Left/Right while others (kitty, xterm) handle it smoothly
" Better to set it anyway.

" Ctrl
nmap <ESC>[1;5D <C-Left>
nmap <ESC>[1;5C <C-Right>
cmap <ESC>[1;5D <C-Left>
cmap <ESC>[1;5C <C-Right>
imap <ESC>[1;5D <C-o><C-Left>
imap <ESC>[1;5C <C-o><C-Right>
" Alt
nmap <ESC>[1;3D <Nop>
nmap <ESC>[1;3C <Nop>
cmap <ESC>[1;3D <Nop>
cmap <ESC>[1;3C <Nop>
imap <ESC>[1;3D <Nop>
imap <ESC>[1;3C <Nop>
" }}}
" }}}
" }}}

" Bindings {{{
" using default mapleader -> '\'

nnoremap <silent> <leader>w :w<CR>
nnoremap <silent> <leader>V :e $MYVIMRC<CR>
nnoremap <silent> <leader>% :so %<CR>

" navigation {{{
" lines
nnoremap B ^
nnoremap E $
" windows
nnoremap <silent> <leader>l :ls<CR>
nnoremap <silent> <leader>L :ls!<CR>
nnoremap <silent> <leader>q :bprev<CR>
nnoremap <silent> <leader>p :bnext<CR>
nnoremap <silent> <leader>s :split<CR>
nnoremap <silent> <leader>v :vsplit<CR>
nnoremap <leader>e :enew<CR>
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l
nnoremap <C-Left> <C-w>h
nnoremap <C-Down> <C-w>j
nnoremap <C-Up> <C-w>k
nnoremap <C-Right> <C-w>l
" tabs
nnoremap <silent> <leader>t :$tabnew<bar>b#<bar>bd!#<CR>
nnoremap <leader>T :wincmd T<CR>
" non destructive :bd
nnoremap <silent> <leader>D :b#<bar>bd!#<CR>
" window/tab destructive :bd
nnoremap <silent> <leader>d :bd<CR>
" shortcut of of the shortcut <C-w>c
nnoremap <silent> <leader>c :close<CR>
" }}}

" functions keys {{{
" F12 - check vim syntax group for word under cursor {{{
function! SynStack()
  if !exists("*synstack")
    return
  endif
  echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfunc
nnoremap <F12> :call g:SynStack()<CR>
" }}}
" }}}

" }}}

" Custom plugins:
" Bro: A searchable :bro old {{{
function! Bro()
	" only window opened ?
	if expand('%:p') == ''
		" then replace it with the oldfiles list
		:enew | silent 0put =v:oldfiles | 1
	else
		" create a new tiny bottom window with old files
		:new +setl\ buftype=nofile | silent 0put =v:oldfiles | 1
		:wincmd J | resize 10
	endif
	" entering automatic search
	":nnoremap n nzzzv | nnoremap N Nzzzv | call feedkeys('/')
	" open selected on enter, and clean previous buff
	:nnoremap <silent> <buffer> <CR>
		\ :e <C-r>=getline('.')<CR><CR>
		\ :bd!#<CR>
		\ :silent wincmd o<CR>
endfunction
" Add ':Bro' to cmdline
command! Bro call Bro()
" map leader r to :Bro
nnoremap <silent> <leader>r :Bro<CR><CR>
" replace :bro with :Bro
cnoreabbrev <expr> bro (getcmdtype() ==# ':' && getcmdline() ==# 'bro')
			\ ? 'Bro' : 'bro'
" }}}
" highlight trailing spaces in red {{{
augroup HighlightUselessWhitespaceInRed
	autocmd!

	" does not get triggered whilst you are typing in insert mode
	:highlight ExtraWhitespace ctermbg=darkred guibg=darkred
	autocmd ColorScheme * highlight ExtraWhitespace ctermbg=red guibg=red
	match ExtraWhitespace /\s\+$/
	autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
	autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
	autocmd InsertLeave * match ExtraWhitespace /\s\+$/
	autocmd BufWinLeave * call clearmatches()
augroup END
" }}}
" automatically restore the previous cursor position {{{
function! ResCur()
  if line("'\"") <= line("$")
    normal! g`"
    return 1
  endif
endfunction
augroup resCur
  autocmd!
  autocmd BufWinEnter * call ResCur()
augroup END

" keywords: - vim.fandom.com
"           - restore_cursor_to_file_position_in_previous_editing_session
" }}}
" Ag as grep {{{
set grepprg=ag\ --color\ --vimgrep

function! Grep(...)
	echo join([&grepprg] + [expandcmd(join(a:000, ' '))], ' ')
	return system(join([&grepprg] + [expandcmd(join(a:000, ' '))], ' '))
endfunction
command! -nargs=+ -complete=file_in_path -bar Grep  cgetexpr Grep(<f-args>)
cnoreabbrev <expr> grep  (getcmdtype() ==# ':' && getcmdline() ==# 'grep')  ?  'Grep'  : 'grep'
command! -nargs=+ -complete=file_in_path -bar LGrep lgetexpr Grep(<f-args>)
cnoreabbrev <expr> lgrep (getcmdtype() ==# ':' && getcmdline() ==# 'lgrep') ?  'LGrep' : 'lgrep'

" if any match, send the output of the Grep command to the quickfix list and set the cursor inside
augroup quickfix
	autocmd!
	autocmd QuickFixCmdPost cgetexpr cwindow
	autocmd QuickFixCmdPost lgetexpr lwindow
	" autocmd QuickFixCmdPost grep cwindow
augroup END
" }}}

colorscheme my-eighties

augroup onVimEnterRestoreSessionIfAny
	autocmd!
	function! RestoreSess()
		if filereadable(expand("~/Session.vim"))
			source ~/Session.vim
		endif
	endfunction

	" :h automcmd-nested
	autocmd VimEnter * nested call RestoreSess()
augroup END

augroup onSaveSourceVimrc
	autocmd!
	autocmd BufWritePost * nested if expand($MYVIMRC) ==# expand('%:p')
				\ | source $MYVIMRC
				\ | echo ".vimrc saved and reloaded!"
				\ | endif
augroup END

" vim: fdm=marker
