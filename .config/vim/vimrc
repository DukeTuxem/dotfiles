
"           |  \
"  __     __ \▓▓______ ____   ______   _______
" |  \   /  \  \      \    \ /      \ /       \
"  \▓▓\ /  ▓▓ ▓▓ ▓▓▓▓▓▓\▓▓▓▓\  ▓▓▓▓▓▓\  ▓▓▓▓▓▓▓
"   \▓▓\  ▓▓| ▓▓ ▓▓ | ▓▓ | ▓▓ ▓▓   \▓▓ ▓▓
"    \▓▓ ▓▓ | ▓▓ ▓▓ | ▓▓ | ▓▓ ▓▓     | ▓▓_____
"     \▓▓▓  | ▓▓ ▓▓ | ▓▓ | ▓▓ ▓▓      \▓▓     \
"      \▓    \▓▓\▓▓  \▓▓  \▓▓\▓▓       \▓▓▓▓▓▓▓


" Always use the XDG Base Directory specification {{{

" copied from: https://wiki.archlinux.org/title/XDG_Base_Directory

" :h set-args (^=)
set runtimepath^=$XDG_CONFIG_HOME/vim
set runtimepath+=$XDG_DATA_HOME/vim
set runtimepath+=$XDG_CONFIG_HOME/vim/after

set packpath^=$XDG_DATA_HOME/vim,$XDG_CONFIG_HOME/vim
set packpath+=$XDG_CONFIG_HOME/vim/after,$XDG_DATA_HOME/vim/after

let g:netrw_home = $XDG_DATA_HOME."/vim"
call mkdir($XDG_DATA_HOME."/vim/spell", 'p')

set backupdir=$XDG_CACHE_HOME/vim/backup | call mkdir(&backupdir, 'p')
set directory=$XDG_CACHE_HOME/vim/swap   | call mkdir(&directory, 'p')
set undodir=$XDG_CACHE_HOME/vim/undo     | call mkdir(&undodir,   'p')
set viewdir=$XDG_STATE_HOME/vim/view     | call mkdir(&viewdir,   'p')

call mkdir($XDG_STATE_HOME."/vim", 'p')
if !has('nvim') | set viminfofile=$XDG_STATE_HOME/vim/viminfo | endif
" }}}
" Autoinstall plugin manager and plugins if missing {{{
if empty(glob('$XDG_CONFIG_HOME/vim/autoload/plug.vim'))
  silent !curl -fLo $XDG_CONFIG_HOME/vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd! VimEnter * PlugInstall --sync | source $MYVIMRC
endif
" run PlugInstall if there are missing plugins
autocmd! VimEnter * if len(filter(values(g:plugs), '!isdirectory(v:val.dir)'))
	\ | PlugInstall --sync | source $MYVIMRC | endif
" }}}

call plug#begin('$XDG_CONFIG_HOME/vim/.vim-plug')
" UI
Plug 'Yggdroot/indentLine'	" show indent levels of spaces
Plug 'preservim/tagbar'         " outline symbols (requires ctags)
Plug 'junegunn/fzf'
" motions
Plug 'tpope/vim-commentary'	" gcc / gcap / ...
Plug 'tpope/vim-surround'	" cs([
Plug 'wellle/targets.vim'	" di(
Plug 'romainl/vim-cool'		" see: /and vim-cool

Plug 'tpope/vim-obsession'      " nice to create sessions

Plug 'tpope/vim-repeat'

Plug 'preservim/NERDTree'

Plug 'vimwiki/vimwiki'

Plug 'junegunn/vim-easy-align'

" ToImplement
Plug 'itchyny/lightline.vim'	" lighter status bar than airline
Plug 'tpope/vim-fugitive'       " Stage current file from vim, restore...
Plug 'airblade/vim-gitgutter'   " Actual modifications inside the buffer
Plug 'tpope/vim-vinegar'

" themes
Plug 'morhetz/gruvbox'
Plug 'chriskempson/base16-vim'	" cool to test completion
Plug 'joshdick/onedark.vim'	" kind of fallback...
Plug 'karoliskoncevicius/oldbook-vim'
Plug 'sainnhe/everforest'
call plug#end()


let mapleader = "\\"

" stuff to merge

nnoremap <leader><CR> :! clear && echo <BAR> ./%<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" User Interface (return from the screen)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Terminal: (parent process)
set title
set titlestring=VIM

" Appearance:
set number		" show the line numbers on the left side...
set relativenumber	" ...with the numbers relative to the current line
set colorcolumn=80	" show a limit with a vertical mark bar
set conceallevel=0	" never replace any symbol like lambda sign, whatever
set nowrap		" allow long lines to extend as far as they go

set lazyredraw		" faster execution of macros, mappings, etc...

set belloff=all		" no bell
set novisualbell	" disable sound
set vb t_vb=		" clearing the visual bell length deactivates flashing

" <plugin> mark indentation levels
let g:indentLine_char = '┊'
let g:indentLine_setColors = 1

" Cursor:
" scroll
" don't scroll on first line but center cursor
nnoremap <expr> <C-d>    line('.') == 1 ? 'M' : '<C-d>zzzv'
nnoremap <C-d>  <C-d>zzzv
nnoremap <C-u>  <C-u>zzzv
" next/prev location
nnoremap <C-i>  <C-i>zzzv
nnoremap <C-o>  <C-o>zzzv
" go to tag
nnoremap <C-]> <C-]>zzzv
" search
nnoremap n nzzzv
nnoremap N Nzzzv
" join
nnoremap J mzJ`z
" horizontal scrolling
nnoremap zl zL
nnoremap zh zH
" wrapped lines scrolling
nnoremap j gj
nnoremap k gk

" Splits:
" more natural default behavior
set splitbelow
set splitright

" create quick splits
nnoremap <silent> <leader>s :split<CR>
nnoremap <silent> <leader>v :vsplit<CR>

" navigation shortcuts
" vimwiki (Backspace key)
nnoremap <C-h>		<C-w>h
nnoremap <C-j>		<C-w>j
nnoremap <C-k>		<C-w>k
nnoremap <C-l>		<C-w>l

nnoremap <C-Up>		<C-w>k
nnoremap <C-Left>	<C-w>h
nnoremap <C-Down>	<C-w>j
nnoremap <C-Right>	<C-w>l


" Tabs:
" better to <C-W>T on a previous buffer
" nnoremap <silent> <leader>t :tabnew<CR>
" non layout destructive :bd
nnoremap <silent> <leader>d :b#<bar>bw!#<CR>
" window/tab destructive :bd
nnoremap <silent> <leader>D :bd<CR>
" shortcut of of the shortcut <C-w>c
nnoremap <silent> <leader>c :close<CR>

nnoremap <silent> <leader>l :ls<CR>
nnoremap <silent> <leader>L :ls!<CR>
nnoremap <silent> <leader>q :bprev<CR>
nnoremap <silent> <leader>p :bnext<CR>
nnoremap <leader>e :enew<CR>
" Zoom without <C-o>
nnoremap <silent> <leader>t :-tab split<CR>
" Then close with <leader>c


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Edition (fed to the process) in the idea
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

set hidden

set mouse=a

set backspace=indent,eol,start	" erase back even in insert mode

set textwidth=79	" do break text with a newline after n typped chars
set nojoinspaces	" leave only one space when joining (gqg)

set noautochdir        " autochdir changes the global directory, not win/tab
set noswapfile

set tags=tags

" Files:
set encoding=UTF-8
set autoread		" reload files changed outside vim
augroup onFocusAttemptToTriggerAutoread
	autocmd!
	" note: this is still not close to real-time
	autocmd FocusGained,BufEnter * :checktime
augroup END

set modeline		" enable <fileCommentChar> vim: fdm=marker
set modelines=1		" limit lines to read

" Tabs:			(Historical reason to choose 8 as a default)
set tabstop=8		" number of spaces that a <Tab> in a file counts for
set shiftwidth=0	" number of spaces to use for each step of (auto)indent
set softtabstop=0	" do not mix space and tabs to make up a set spacing
set noexpandtab		" never replace tabs with space

" Search:
set hlsearch		" highlight searches by default
set incsearch		" find the next match as we type the search
set ignorecase		" ignore case when searching...
set smartcase		" ...unless we type an uppercase letter

" always start a search from the cursor position
" not incremental :(
" nnoremap / :.,$/

" search for the currently selected text in the file
vnoremap / y/\V<C-R>=escape(@",'/\')<CR><CR>

" should be to replace a selection (is there simpler ?)
" function! GetVisualSelection()
"   " Why is this not a built-in Vim script function?!
"   let [line_start, column_start] = getpos("'<")[1:2]
"   let [line_end, column_end] = getpos("'>")[1:2]
"   let lines = getline(line_start, line_end)
"   if len(lines) == 0
"     return ''
"   endif
"   let lines[-1] = lines[-1][: column_end - (&selection == 'inclusive' ? 1 : 2)]
"   let lines[0] = lines[0][column_start - 1:]
"   let arf = join(lines, "\n")
"   exe ':%s/'.arf."/gc<Left><Left><Left>"
" endfunction

" Completion_menu:
set wildmenu	" do not spam TAB in command line
set wildmode=list:longest,list:lastused,list:full
set wildignore=*.jpg,*.png,*.gif,*.pdf,*.pyc,*.flv,*.img
"set wildchar=<Tab> wildmenu wildmode=full
set wildcharm=<TAB>   " recognize tab as completer command in mappings

"set matchtime=3        " ... and shorten the default time -> zt zb zz H M L
"set scrolloff=5        " scroll before the end of buffer but affect H/M/L too
" nnoremap S :.,$s//gc<Left><Left><Left>
" and vim-cool is used to remove highlighted searches automatically (no :nohl)

" Folds:
set foldenable
set foldmethod=marker
" what is '1' setting for below ? (some folds ? How come)
set foldlevelstart=0	" close most folds by default
set foldnestmax=2	" open most folds by default
set foldopen-=block	" do not open ( { [ folds when passing (hjkl) on them
"set foldclose=all	" auto close fold when leaving the fold scope

" Tell vim to remember certain things when we exit
"  '10   :  marks will be remembered for up to 10 previously edited files
"  "1000 :  will save up to 1000 lines for each register
"  :20   :  up to 20 lines of command-line history will be remembered
"  %     :  saves and restores the buffer list | off - (use sessions if needed)
"  h     :  disable the effect of 'hlsearch'
"  n...  :  where to save the viminfo files | viminfofile set above
set viminfo='10,\"1000,:20,h

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Color
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" use truecolor (24bit-mode)
set termguicolors

if &term =~ "^st"
	" from :help xterm-true-color
	let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
	let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"

	" Fixes mouse scrolling in st. Update: it seems fixed
	"set ttymouse=sgr
endif

colorscheme my-eighties



"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Statusline
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set showcmd		" show the command being typed. Ex: "a
set noruler		" deactivate line:column in ruler (handled in plugin)
set showmatch		" briefly highlight the matching ( { [ if any

"-- lightline settings
set noshowmode
set laststatus=2
let g:lightline = {
\ 'colorscheme': 'darcula',
\ }

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Command Line
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" remap colon to semicolon
nnoremap ; :
nnoremap : ;
vnoremap ; :
vnoremap : ;

" arrow up/down in :cmdline
cnoremap <C-k> <Up>
cnoremap <C-j> <Down>

" open help on the right
cnoreabbrev h vert h

" Terminal: (:term)
" rebind escape to avoid <C-w><S-N>
tnoremap <C-[> <c-\><c-n>
" impossible on MS-Windows -> :h scroll-mouse-wheel
tnoremap <ScrollWheelUp> <C-\><C-n><C-u>
tnoremap <ScrollWheelDown> <C-d>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Fuzzy Finding
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

nnoremap <leader>f :FZF<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Function keys
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" F1 : Help
nnoremap <F2> :set wrap!<CR>
" TODO: " during the paste can this action happen automatically ?
set pastetoggle=<F3>
nnoremap <F4> :set list!<CR>

nnoremap <F12> :call g:SynStack()<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Language specific
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Perl:
let perl_fold=1
let perl_nofold_subs=1
let g:perldoc_split_modifier = 'rightbelow 15'

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" netrw
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" allow netrw buffers to be closed
let g:netrw_fastbrowse = 0
" let g:netrw_fastbrowse = 0
" let g:netrw_banner = 0					" remove header
" let g:netrw_liststyle = 3				" tree like listing
" let g:netrw_browse_split = 4		" open in previous buffer
" let g:netrw_altv = 1
" let g:netrw_winsize = 30
" let g:netrw_list_hide = &wildignore
" let g:netrw_bufsettings = 'noma nomod nu nobl nowrap ro'
" nnoremap <leader>n :Lex<CR>

" " https://www.reddit.com/r/neovim/comments/jr5zdb/remapping_keys_in_netrw/
" augroup netrw_mapping
"   autocmd!
"   autocmd filetype netrw call NetrwMapping()
" augroup END

" function! NetrwMapping()
"   " keep the behavior bound to <CR> with nmap
"   nmap <buffer> l <CR>
"   nmap <buffer> h -
"   nnoremap <buffer> <C-l> <C-W>l
" endfunction

" augroup NERDTreeSetRela
"   autocmd !
"   autocmd BufWinEnter NERD_* setlocal relativenumber
" augroup END


" Tosort:

" perform dot commands over visual blocks:
vnoremap . :normal .<CR>

" ignore a text to replace from being recorded in registers
nnoremap c "_c

" consistent mapping
nnoremap Y y$

" what is it btw ?
nnoremap <expr> ' "'" . nr2char(getchar()) . "zz"
nnoremap <expr> ` "`" . nr2char(getchar()) . "zz"

" Todo: a cursor plugin ?
" automatically restore the previous cursor position
" keywords: - vim.fandom.com
"           - restore_cursor_to_file_position_in_previous_editing_session
function! ResCur()
  if line("'\"") > 1 && line("'\"") <= line("$")
    silent normal! g`"
    return 1
  endif
endfunction

augroup resCur
  autocmd!
  autocmd BufWinEnter * call ResCur()
augroup END


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Plugins config
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" GitGutter:
nmap <leader>Hp  <Plug>(GitGutterPreviewHunk)
nmap <leader>Hu  <Plug>(GitGutterUndoHunk)
nmap <leader>Hs  <Plug>(GitGutterStageHunk)
xmap <leader>Hs  <Plug>(GitGutterStageHunk)

" Vimwiki:
let g:vimwiki_list = [{'path': '~/documents/vimwiki',
			\ 'syntax': 'markdown', 'ext': '.md'}]

" [terminal] this conflicts with the shortcut <C-W>H mapping
" not a big deal since I am often dealing with vimwiki in a separate tab
augroup onVimwikiBindShiftBackspace
	autocmd!
	autocmd FileType vimwiki nnoremap <silent><buffer> <C-H> :VimwikiGoBackLink<CR>
augroup END




"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Vim
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" avoid mistake and unattend effects
map <C-a> <Nop>
map <C-x> <Nop>

augroup onVimEnterRestoreSessionIfAny
	autocmd!
	function! RestoreSess()
		" [Gvim specific]
		" do not restore the session if v:servername contains numbers.
		" if so, it means an existing vim instance is running, but the
		" goal is to have a fresh one started, not a mirrored instance
		if filereadable(expand("~/Session.vim")) && v:servername !~ '\d'
			source ~/Session.vim
		endif
	endfunction

	" :h automcmd-nested
	autocmd VimEnter * nested call RestoreSess()
augroup END

augroup sourceVimrcOnSave
	autocmd!
	autocmd BufWritePost * nested if expand($MYVIMRC) ==# expand('%:p')
				\ | source $MYVIMRC
				\ | echo ".vimrc saved and reloaded!"
				\ | endif
augroup END

" quick edit vimrc in a new tab
nnoremap <silent> <leader>V :tabnew $MYVIMRC<CR>zozz
