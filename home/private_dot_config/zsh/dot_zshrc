#                       __
#                      |  \
#     ________  _______| ▓▓____   ______   _______
#    |        \/       \ ▓▓    \ /      \ /       \
#     \▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓\  ▓▓▓▓▓▓\  ▓▓▓▓▓▓▓
#      /    ▓▓ \▓▓    \| ▓▓  | ▓▓ ▓▓   \▓▓ ▓▓
#  __ /  ▓▓▓▓_ _\▓▓▓▓▓▓\ ▓▓  | ▓▓ ▓▓     | ▓▓_____
# |  \  ▓▓    \       ▓▓ ▓▓  | ▓▓ ▓▓      \▓▓     \
#  \▓▓\▓▓▓▓▓▓▓▓\▓▓▓▓▓▓▓ \▓▓   \▓▓\▓▓       \▓▓▓▓▓▓▓



# Uncomment here and `#zprof` to audit startup time
# zmodload zsh/zprof

# Environment variables - in an interactive context {{{

### System:
export EDITOR='vim'
export PAGER='less'
# R: raw-chars
# F: quit-on-EOF
# S: wrap-lines
# X: don't-clear-screen
# g: one-match-color-search
# j: center screen
export LESS='-RFSXg -j.5'

### Custom:
export DISTRO=$(awk -F= '/^ID=/ {gsub(/"/, "", $2); print $2}' /etc/os-release)
## Default apps
export BROWSER='firefox'
export PLAYER='mpv'
# export EXPLORER=''
# export TERMINAL=''

### Preferences
# Dark theme
export QT_STYLE_OVERRIDE='kvantum-dark'
# }}}
# User eXperience / fixes / expected defaults {{{

### Anything that can be so itchy if not set, colors, expected defaults...
### Since this file is loaded early, it is not meant to implement plugins, or
### add complex logic. This is just _overriding_ the defaults in the idea.

### Miscellaneous
setopt NOTIFY	# Report background job status immediately vs next prompt
unsetopt BEEP	# That lovely bell sound, is it off by default?

### Fixes
## GUI:
# Java apps now work with Tiling Window Managers
export _JAVA_AWT_WM_NONREPARENTING=1
# Fix awfully looking fonts in java apps
export _JAVA_OPTIONS='-Dawt.useSystemAAFontSettings=on -Dswing.aatext=true'

## CLI:

## XDG:
# this is 'because' I use wget that I need the fix to be here.
alias wget='wget --no-hsts'

### Tweaks
alias \
	diff='diff --color=auto'					\
	dmesg='dmesg -L=auto'						\
	df='df -h'							\
	du='du -h'							\
	feh='feh --scale-down --full-screen'				\
	grep='grep --color=auto'					\
	ls='ls -h --color=auto --group-directories-first'		\
	mkdir='mkdir -p'						\
	mpv='mpv --fullscreen'						\
	nnn='nnn -e'							\
	patch='patch --reject-file=/dev/null --no-backup-if-mismatch --merge' \
	tree='tree -C --dirsfirst'					\
	watch='watch --color'						\
	xterm='xterm -bg black -fg white'

# Enable color in less and use as much width as possible
# md = Start bold effect (double-bright).
# me = Stop bold effect.
# us = Start underline effect.
# ue = Stop underline effect.
# so = Start stand-out effect (similar to reverse text).
# se = Stop stand-out effect (similar to reverse text).
# note: had to export so it would work on other platforms.
export LESS_TERMCAP_md=$'\e[01;34m'	\
	LESS_TERMCAP_me=$'\e[0m'	\
	LESS_TERMCAP_us=$'\e[01;32m'	\
	LESS_TERMCAP_ue=$'\e[0m'	\
	LESS_TERMCAP_so=$'\e[45;43m'	\
	LESS_TERMCAP_se=$'\e[0m'

# Oh...
man() {
	if [ "$DISTRO" = 'void' ]; then
		# man pages are not taking the maximum space...
		command man -O width=$(($(tput cols)-1)) "$@"
	else
		command man "$@"
	fi
}
# }}}
# Bindings and mappings {{{

### In this section:
### 1. Attempt to read the Terminfo database
### 2. Define custom functions/plugins ready to be bound
### 3. In the darkness, bind them all

### Terminfo
# Terminfo is an effort to establish a standard on top of historical different
# terminal emulator implementations.
# As such, the following makes use of the terminfo database to bind some common
# terminal escape sequences 'independantly' of the terminal emulator used.
# See `man terminfo`.

# Explicitely loading the zsh terminfo interface module
zmodload zsh/terminfo

# Custom associative array (-A) to be destroyed after bindings are done
# 'keys' is a custom implementation so it is not compatible with zkbd.
declare -A keys

## Read from the terminfo database for as many key to be mapped
# Commons
keys[Enter]="${terminfo[cr]:-^M}"
keys[EnterNumpad]="${terminfo[kent]:-^M}"
keys[Backspace]="${terminfo[kbs]}"
keys[Delete]="${terminfo[kdch1]}"
keys[Up]="${terminfo[kcuu1]}"
keys[Down]="${terminfo[kcud1]}"
keys[Left]="${terminfo[kcub1]}"
keys[Right]="${terminfo[kcuf1]}"
keys[PageUp]="${terminfo[kpp]}"
keys[PageDown]="${terminfo[knp]}"
keys[Home]="${terminfo[khome]}"
keys[End]="${terminfo[kend]}"
keys[Tab]="${terminfo[ht]}"
keys[ShiftTab]="${terminfo[kcbt]}"
# Combinations
keys[CtrlRight]="^[[1;5C"
keys[CtrlLeft]="^[[1;5D"
keys[CtrlDel]="^[[3;5~"

case $TERM in
	# xterm or tty
        "xterm" | "xterm-256color")
		keys[Backspace]="${keys[Backspace]:-^H}"
		keys[Delete]="${keys[Delete]:-^[[3~}"
		keys[Up]="${keys[Up]:-^[[A}"
		keys[Left]="${keys[Left]:-^[[B}"
		keys[Right]="${keys[Right]:-^[[C}"
		keys[Down]="${keys[Down]:-^[[D}"
		keys[PageUp]="${keys[PageUp]:-^[[5~}"
		keys[PageDown]="${keys[PageDown]:-^[[6~}"
		keys[Home]="${keys[Home]:-^[[H}"
		keys[End]="${keys[End]:-^[[F}"
		keys[Tab]="${keys[Tab]:-	}"
		keys[ShiftTab]="${keys[ShiftTab]:-^[[Z}"
		;;
	# also tmux
	"screen" | "screen-256color")
		# fix backspace
			keys[Backspace]="${terminfo[kbs]:-^?}"
		keys[Delete]="${terminfo[kdch1]:-^[[3~}"
		keys[Up]="${terminfo[kcuu1]:-^[[A}"
		keys[Down]="${terminfo[kcud1]:-^[[B}"
		keys[Right]="${terminfo[kcuf1]:-^[[C}"
		keys[Left]="${terminfo[kcub1]:-^[[D}"
		keys[PageUp]="${terminfo[kpp]:-^[[5~}"
		keys[PageDown]="${terminfo[knp]:-^[[6~}"
			keys[Home]="${terminfo[khome]:-^[[1~}"
			keys[End]="${terminfo[kend]:-^[[4~}"
		keys[Tab]="${terminfo[ht]:-	}"
		keys[ShiftTab]="${terminfo[kcbt]:-^[[Z}"
		;;
	"linux")
		keys[CtrlLeft]="^[[D"
		keys[CtrlRight]="^[[C"
		;;
	"st" | "st-256color")
		# st has both cbt and kcbt declared in its st.info file but in
		# the end, infocmp only shows cbt (tested on debian), and kcbt
		# is set to empty. Both have the same value, so we use cbt.
		keys[ShiftTab]="${terminfo[cbt]}"
		;;
	*)
		echo >&2 "Unsupported terminal!"
		;;
esac


### Plugins

# backward-kill-word has to mind '/' and '$' as separators
custom-backward-kill-word() {
	# A list of non-alphanumeric characters
	# considered part of a word by the line editor.
	local WORDCHARS='*?-[]~=&;!#%^(){}<>|_.'
	zle backward-kill-word
}
# create a user-defined zle widget to be bound later
zle -N custom-backward-kill-word

# Allow to execute vim with the current edited command in buffer
autoload edit-command-line;
zle -N edit-command-line


### Bindings from scratch

### Overall:
### --------
### Exception for Alt+BS, otherwise no mixing with the Window Manager bindings!
### Alt + ~
### Alt + F1..F12
### ^ Those should be reserved for some Windows Manager functionnality
### --
### Zsh can use F1-F12 or even Ctrl+FX

### Reminder:
### --------
### ASCII[28] == File Separator == \034 == \x1c == Ctrl + \ == "^\\\\"
### -> 'showkey -a' is really helpful

## Erase everything then rebind
# Disable Ctrl + s / Ctrl + q (XON/XOFF) to free up two mappings
setopt NOFLOWCONTROL
# Remove (-r) all bindings from an empty prefix (-p), which matches all.
bindkey -rp ''

## Free: F1..F12

## Terminfo
# bindkey -- marks the end of options so only arguments are passed
bindkey -- "${keys[Enter]}" 		accept-line
bindkey -- "${keys[EnterNumpad]}"	accept-line
bindkey -- "${keys[Backspace]}"		backward-delete-char
bindkey -- "${keys[Delete]}"		delete-char
bindkey -- "${keys[Up]}"		up-line-or-history
bindkey -- "${keys[Down]}"		down-line-or-history
bindkey -- "${keys[Left]}" 		backward-char
bindkey -- "${keys[Right]}"		forward-char
bindkey -- "${keys[PageUp]}"		history-beginning-search-backward
bindkey -- "${keys[PageDown]}"		history-beginning-search-forward
bindkey -- "${keys[Home]}"		beginning-of-line
bindkey -- "${keys[End]}"		end-of-line
# fallback behavior for Tab & ShiftTab - since managed by fzf later
bindkey -- "${keys[Tab]}"		expand-or-complete
bindkey -- "${keys[ShiftTab]}"		expand-or-complete

## Letters
# ASCII characters from 32 to 126 as a (-R)ange
bindkey -R -- " "-"~"			self-insert # exclude control chars
bindkey -- "\M-^@"-"\M-^?"		self-insert # internationalization

## Control (^) sequences
# Free: ^[
bindkey -- '^_'				undo
bindkey -- '^@'				redo
# 		-- Top row --
bindkey -- '^Q'				beginning-of-line
bindkey -- '^W'				custom-backward-kill-word
bindkey -- '^E'				edit-command-line
# fallback, will become:		fzf-history-widget
bindkey -- '^R'				history-incremental-search-backward
#bindkey -- '^T'			fzf-file-widget
bindkey -- '^U'				backward-kill-line
#bindkey -- '^O'			FREE
bindkey -- '^P'				end-of-line
# 		-- Home row --
#bindkey -- '^A'			# tmux prefix
#bindkey -- '^S'			FREE
#bindkey -- '^F				# bookmarks with fzf
#bindkey -- '^G'			FREE
bindkey -- '^H'				backward-delete-char
#bindkey -- '^J'			FREE
bindkey -- '^K'				kill-line
bindkey -- '^L'				clear-screen	# no terminfo (ff) ?
bindkey -- '^Y'				yank
# 		-- Bottom row --
#bindkey -- '^X'			FREE
bindkey -- '^V'				quoted-insert
#bindkey -- '^B'			execute-last-named-cmd
#bindkey -- '^N'			execute-named-cmd

## Special
bindkey -- "^[[200~"			bracketed-paste

## Combinations
# 'Portable' Alt + Del
bindkey -- "^[${keys[Backspace]}"	custom-backward-kill-word
bindkey -- "${keys[CtrlRight]}"		forward-word
bindkey -- "${keys[CtrlLeft]}"		backward-word
bindkey -- "${keys[CtrlDel]}"		kill-word


### Make terminfo accessible:
### When running zsh, some terminals (like xterm) will not consider the
### terminfo array if the 'application mode' is not set during line edition.
### This mode is also known as the non-canonical, or raw mode for terminals.
### The terminfo database is only valid in that context, so the following
### enables/disables this mode everytime the zsh line editor is to be used.
if (( ${+terminfo[smkx]} && ${+terminfo[rmkx]} )); then
	autoload -Uz add-zle-hook-widget
	function zle_application_mode_start { echoti smkx }
	function zle_application_mode_stop { echoti rmkx }
	add-zle-hook-widget -Uz zle-line-init zle_application_mode_start
	add-zle-hook-widget -Uz zle-line-finish zle_application_mode_stop
fi

unset keys


### Resources
# `man zshzle`
# https://wiki.archlinux.org/title/zsh#Key_bindings
#
# Understanding CR/LF:
# https://unix.stackexchange.com/questions/253271
#
# How to get control characters for Ctrl+Left from terminfo in Zsh:
# https://stackoverflow.com/questions/31379824/
# }}}
# Navigation {{{

## Options
setopt NOAUTOCD		# require cd for directories (history + no ambiguity)
setopt AUTOPUSHD	# all 'cd's goes to the dir stack history
setopt PUSHDIGNOREDUPS	# only remember the location, not the order

## Directory stack
# A quick cd "history":
# usage: `s` to show the dir stack, any number for quick cd previous/next
alias s='dirs -v | sed 11q'
alias 1='cd -'
alias 2='cd +2'
alias 3='cd +3'
alias 4='cd +4'
alias 5='cd +5'
alias 6='cd +6'
alias 7='cd +7'
alias 8='cd +8'
alias 9='cd +9'
# }}}
# Completion {{{

# TODO: close the completion menu
# bindkey -M menuselect '^[' undo

# =============================================================================
# Global options
# =============================================================================

# Propose completion of dotfiles
setopt GLOBDOTS


# =============================================================================
# Completion init
# =============================================================================

### Explicitely load the complist module (for menu-select)
# Need to be called before compinit is initialized
zmodload zsh/complist
# Required variable to be set to the value of $LS_COLORS
ZLS_COLORS="${LS_COLORS}"
# Since we're here, just set up ahead
zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"

### Make sure the caching directory is not the zsh config folder and use it
[[ ! -d "$XDG_CACHE_HOME/zsh" ]] && mkdir -p "$XDG_CACHE_HOME/zsh"
zstyle ':completion:*' cache-path "$XDG_CACHE_HOME/zsh"
zstyle ':completion:*' use-cache on

### Load the completion module
# Mark compinit as a zsh builtin function (otherwise looked as an executable)
autoload -Uz compinit
# Run the compinit function and respect the XDG_* dirs spec
compinit -d "$XDG_CACHE_HOME/zsh/zcompdump-$ZSH_VERSION"


# =============================================================================
# Completion settings
# =============================================================================

### Completer control functions - ZSHCOMPSYS(1)
# _expand_alias:
# Need to be before _complete
#
# _complete:
# Trigger the actual completion system
#
# _extensions:
# Typing '*.' then tab will list all the current file types in the directory
#
# _approximate:
# Correct 'tyest' to 'test' using tab for a directory to change to, for example
zstyle ':completion:*' completer 			\
					_expand_alias	\
					_complete 	\
					_extensions 	\
					_approximate


### Menu
# Use list for any completion
zstyle ':completion:*' menu select
# Sort list by size then modification time
zstyle ':completion:*' file-sort size change #reverse
zstyle ':completion:*' group-name ''	# Split aliases/cmds/..  by section
# Sections
zstyle ':completion:*:*:*:*:corrections' format '%F{yellow}!- %d (errors: %e) -!%f'
zstyle ':completion:*:*:*:*:descriptions' format '%F{blue}-- %D %d --%f'
zstyle ':completion:*:*:*:*:messages' format ' %F{purple} -- %d --%f'
zstyle ':completion:*:*:*:*:warnings' format ' %F{red}-- no matches found --%f'
# Group by (not sure that it works)
# zstyle ':completion:*:*:-command-:*:*' group-order 			\
# 							aliases 	\
# 							builtins 	\
# 							functions 	\
# 							commands
# ls -l output format in any case (no trigger on numeric threshold)
# -> Does not keep the colors unfortunately... TODO: Search a replacement ?
# zstyle ':completion:*' file-list all

### Misc
# Show all the possibilities for a: 'cd -'
zstyle ':completion:*' complete-options true
# Supposed to show command option descriptions ?
zstyle ':completion:*' verbose yes


# reference:
# zstyle :completion:<function>:<completer>:<command>:<argument>:<tag>
# }}}
# History {{{
HISTFILE="$XDG_STATE_HOME/zsh/history"
HISTSIZE=100000
SAVEHIST=100000
setopt APPEND_HISTORY		# (On by default)
setopt INC_APPEND_HISTORY	# Immediate recording
setopt HIST_IGNORE_DUPS		# Avoid ls ls ls ls
setopt HIST_IGNORE_SPACE	# Do not record ' cmd'
# }}}
# Prompt {{{

# ISSUE#1: Thanks Tmux for changing my favorite ls colors...
# [[ "$TERM" == "screen-256color" ]] && source "$XDG_CONFIG_HOME/tmux/ls.env"
autoload -Uz colors && colors
#bindkey -- "^X^R" _read_comp
#bindkey -- "^X?" _complete_debug
#bindkey -- "^XC" _correct_filename
#bindkey -- "^Xa" _expand_alias
#bindkey -- "^Xc" _correct_word
#bindkey -- "^Xd" _list_expansions
#bindkey -- "^Xe" _expand_word
#bindkey -- "^Xh" _complete_help
#bindkey -- "^Xm" _most_recent_file
#bindkey -- "^Xn" _next_tags
#bindkey -- "^Xt" _complete_tag
#bindkey -- "^X~" _bash_list-choices
#bindkey -- "^[," _history-complete-newer
#bindkey -- "^[/" _history-complete-older
#bindkey -- "^[~" _bash_complete-word

setopt PROMPTSUBST	# Required for string interpolation in prompt

# autoload -Uz VCS_INFO

# zstyle ':vcs_info:*' enable git
# zstyle ':vcs_info:*' formats       '%F{5}(%F{cyan}%b%F{5})%f'
# zstyle ':vcs_info:*' actionformats '%F{5}(%F{cyan}%b%F{3})%F{1}%a%F{5}]%f'
# zstyle ':vcs_info:(sv[nk]|bzr):*' branchformat '%b%F{1}:%F{3}%r'
# # Enable checking for (un)staged changes, enabling use of %u and %c
# zstyle ':vcs_info:*' check-for-changes true
# # Set custom strings for an unstaged vcs repo changes (*) and staged changes (+)
# zstyle ':vcs_info:*' unstagedstr ' *'	# ongoing modifications
# zstyle ':vcs_info:*' stagedstr ' +'		# todo: push
# ✗



timer_show=
# Except when the shell is started, add one new line after each command.
precmd() {
	# Override the precmd() with the following function
	# which will then be executed after each command
	#precmd() {
	#    echo
	#}

	if [ $timer ]; then
		timer_show=$(($SECONDS - $timer)) # $SECONDS is an internal var
		unset timer
	fi
	# vcs_info
}

preexec() {
	timer=${timer:-$SECONDS}
}


# PROMPT == PS1
# %B/%b bold
# %F/%f color{red|green|blue|magenta|cyan|white}
PS1="%B"				# start bold mode
PS1="$PS1%F{green}%n"			# green username
PS1="$PS1%F{yellow}@"			# yellow @
PS1="$PS1%F{blue}%M "			# blue hostname
PS1="$PS1%F{magenta}%~ "		# magenta path
# PS1="$PS1%f%b\$vcs_info_msg_0_ "	# stop color & bold

PS1="$PS1%1(j.%F{yellow} %j .)%f"	# yellow background jobs
PS1="$PS1%(?.%F{green}√.%F{red}%?)%f"	# √ or fail code on the right

PS1="$PS1"$'\n'				# split prompt

PS1="$PS1%B%F{yellow} %b%f"		# prompt char itself


# TODO: tty depending prompt (with battery status, replacement of dwm...)
#cd ~/dwm
# }}}
# exa.zsh previous file {{{
# https://www.cyberciti.biz/open-source/bat-linux-command-a-cat-clone-with-written-in-rust///////////////////////////////
# Create new aliases to use a colored output instead of ls

# if has command exa then...
# }}}
#  Fuzzy File Finding {{{

### Loading
# From fzf changelog v0.48.0:
# Shell integration scripts are now embedded in the fzf binary
autoload -Uz is-at-least
if is-at-least 0.48.0 "$(fzf --version | cut -d ' ' -f 1)"
then
	source <(fzf --zsh)
	# source /usr/share/fzf/completion.zsh
	# source /usr/share/fzf/key-bindings.zsh
else
	if [ "$DISTRO" = 'debian' ]; then
		source /usr/share/doc/fzf/examples/completion.zsh
		source /usr/share/doc/fzf/examples/key-bindings.zsh
	fi
fi

### Settings
# underlying binary used by fzf
fdbin='fd'
[ "$DISTRO" = 'debian' ] && fdbin='fdfind'

# FuzZy Finder - So awesome...
# - $FZF_TMUX_OPTS
# - $FZF_CTRL_T_COMMAND
# - $FZF_CTRL_T_OPTS
# - $FZF_CTRL_R_OPTS
# - $FZF_ALT_C_COMMAND
# - $FZF_ALT_C_OPTS
export FZF_DEFAULT_COMMAND="$fdbin -H --exclude 'node_modules' --exclude 'mozilla' --exclude '.git'"
export FZF_DEFAULT_OPTS="--height 40% --layout=reverse --preview '(highlight -O ansi {} || cat {}) 2> /dev/null | head -500'"

export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
export FZF_ALT_C_COMMAND="$FZF_DEFAULT_COMMAND"

function fzf-in-home() {
  local choice=$(eval $FZF_DEFAULT_COMMAND . '$HOME' | fzf)
  zle reset-prompt
  LBUFFER="${LBUFFER}$choice"
}
zle -N fzf-in-home
bindkey -- "^G" fzf-in-home

#"^I" fzf-completion
#"^R" fzf-history-widget
#"^T" fzf-file-widget
#"^[c" fzf-cd-widget
unset fdbin
# }}}
# fzf-powered bookmark navigation plugin {{{
# note: no need to export, every zsh interactive shell will know this variable,
# as this file is sourced inevitably.
# The only use case would be for another program or script run externally,
# like a zsh script, run from my interactive shell, that would then not see it.
# But it's not necessary since it's meant to be used only here.
CDFAVS="$XDG_DATA_HOME"/zsh/favs.txt

alias cdf='eval cd $(fzf < $CDFAVS)'
alias efav="$EDITOR $CDFAVS"
alias favs="$PAGER $CDFAVS"
alias f="favs"

change-directory-favorites() {
	local choice="$(fzf < $CDFAVS)"
	if [[ "$choice" ]]; then
		eval cd "$choice"
		zle accept-line
	else
		# in case of Ctrl-C
		zle reset-prompt
	fi
}
zle -N change-directory-favorites
bindkey -- "^F" change-directory-favorites

addfav() {
	local compute() {
		# Do not add an invalid folder or a duplicate entry
		if [ ! -d "$1" ]; then
			echo >&2 "'$1' is not a valid directory."
			return 1
		elif grep -Fxq "$1" "$CDFAVS"; then
			echo >&2 "'$1' is already in favorites."
			return 1
		fi

		# Add the directory to the favorites file and keep it sorted
		echo "$1" >> "$CDFAVS" && sort -uo "$CDFAVS" "$CDFAVS"
		echo "Added '$1' to favorites."
	}

	# No argument given: add the current folder
	if [ "$#" -eq 0 ]; then
		compute $(realpath "$PWD")
		return $?
	# Add as many valid directories as given
	else
		local err=0
		for fav in "$@"; do
			compute "$(realpath -- "$fav")"
			[ $? -gt 0 ] && err=1
		done
		unset fav
		return $err
	fi
}

delfav() {
	local compute() {
		# Deleting line if it exists
		if grep -Fxq "$1" "$CDFAVS"; then
			echo "Deleting '$1' from favorites."
			local filtered_file=$(grep -Fvx "$1" "$CDFAVS")
			echo "$filtered_file" > "$CDFAVS"
			return 0
		fi
		echo >&2 "Directory '$1' not found in the list."
		return 1
	}

	# No argument: try to delete the current directory
	if [ "$#" -eq 0 ]; then
		compute $(realpath "$PWD")
		return $?
	# Delete as many valid favorites directories as given
	else
		local err=0
		for fav in "$@"; do
			compute "$(realpath -- "$fav")"
			[ $? -gt 0 ] && err=1
		done
		unset fav
		return $err
	fi
}

# Parse all favorite directories and clean unexisting entries
chkfav() {
	local to_del=()
	# IFS= (or '') prevents leading/trailing whitespace from being trimmed.
	# -r prevents backslash escapes from being interpreted.
	while IFS='' read -r local fileline
	do
		[ ! -d "$fileline" ] && to_del+=("$fileline")
	done < "$CDFAVS"

	for fav in $to_del; do
		delfav "$fav"
	done
	local err=$?
	unset fav
	return $err
}
# }}}
# Aliases / shortcuts {{{

### Shortcuts
## Based on commands
alias \
	agi='ag -i --hiden'			\
	cm='chezmoi'				\
	gad='git add'				\
	gbr='git branch -a'			\
	gch='git checkout'			\
	gco='git commit'			\
	gdi='git diff'				\
	gdis='git diff --staged'		\
	glo='git log --graph --decorate --all'	\
	gpu='git push'				\
	gst='git status'			\
	j='jobs'				\
	la='ls -a'				\
	ll='ls -l'				\
	lla='ls -al'				\
	ons='alsamixer'				\
	se='sudoedit'				\
	smci='sudo make clean install'		\
	vi="vim" 				\
	vw='vim -c VimwikiIndex'		\
	xinst='sudo xbps-install'		\
	xquery='xbps-query'			\
	xremove='sudo xbps-remove'

## Based on configuration
alias \
	cmcd="cd $(chezmoi source-path)/.."			\
	reload="source $ZDOTDIR/zshrc"				\
	tconf="$EDITOR $XDG_CONFIG_HOME/tmux/tmux.conf"		\
	vconf="$EDITOR $XDG_CONFIG_HOME/vim/vimrc"			\
	xinitrc="$EDITOR $XDG_CONFIG_HOME/x11/xinitrc"		\
	zconf="$EDITOR $ZDOTDIR/.zshrc"

## TODO: dirty admin to fix
alias \
	rack='sudo sshfs -oIdentityFile="$HOME"/.ssh/id_ed25519,allow_other root@192.168.50.179:/mnt /mnt/rack' \
	unrack='sudo umount -l /mnt/rack' \
	lsblk="lsblk; echo; ps aux | awk 'NR==1 || /sftp/ && !/awk/'"

# if X11 vs wayland...
alias clip='xclip -selection clipboard'
# }}}
# Commands {{{
# NVM & Lazy loading
export NVM_DIR="$XDG_CONFIG_HOME/nvm"

function _load_nvm() {
	unset -f nvm npm npx node _load_nvm
	[ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
	"$@"
}
function node { _load_nvm node "$@"; }
function npm { _load_nvm npm "$@"; }
function npx { _load_nvm npx "$@"; }
function nvm { _load_nvm nvm "$@"; }

# Vim wrapper to follow symlinks
function vim() {
	local args=()
	for i in "$@"; do
		if [[ -h "$i" ]]; then
			args+=($(readlink "$i"))
		else
			args+=("$i")
		fi
	done
	command vim "${args[@]}"
}
# }}}

# External plugins {{{
#
source "$ZDOTDIR/plugins/you-should-use/you-should-use.plugin.zsh"

# Fish-like syntax pre-validation (should be last)
source "$ZDOTDIR"/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
# }}}

# zprof
